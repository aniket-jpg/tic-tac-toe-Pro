<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <base target="_top">
    <title>Neon Tic Tac Toe Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        /* --- PRO-GAMER NEON CSS V2.1 (Performance & Smoothness Update) --- */
        :root {
            --background-color: #0d0221;
            --grid-color: #ff00ff; /* Magenta */
            --color-o: #00d9ff;      /* Vivid Cyan */
            --color-x: #ff1b8d;      /* Hot Pink */
            --text-color: #f5f5f5;
            --overlay-color: rgba(13, 2, 33, 0.75);
            --bg-grad-1: #0d0221;
            --bg-grad-2: #240b36;
            --fast-bezier: cubic-bezier(0.25, 0.8, 0.25, 1); /* Snappy animation curve */
        }
        html, body {
            height: 100%; margin: 0; padding: 0; overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(45deg, var(--bg-grad-1), var(--bg-grad-2));
            background-size: 200% 200%;
            animation: gradientShift 15s ease infinite;
            color: var(--text-color);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .app-container {
            width: 100%; height: 100%; max-width: 500px;
            margin: 0 auto;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            padding: 20px; box-sizing: border-box;
            position: relative; 
        }
        .view {
            width: 100%; height: 100%;
            display: none; flex-direction: column;
            justify-content: center; align-items: center;
            text-align: center; animation: fadeIn 0.4s var(--fast-bezier);
        }
        .view.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.97); } to { opacity: 1; transform: scale(1); } }
        @keyframes popIn { 0% { opacity: 0; transform: scale(0.6); } 100% { opacity: 1; transform: scale(1); } }
        @keyframes drawLine { to { stroke-dashoffset: 0; } }
        @keyframes pulse { 0%, 100% { transform: scale(1); box-shadow: 0 0 10px, 0 0 20px; } 50% { transform: scale(1.05); box-shadow: 0 0 20px, 0 0 40px; } }
        @keyframes scoreUpdate { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.25); } }
        @keyframes neonFlicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px var(--color-o), 0 0 20px var(--color-o), 0 0 25px var(--color-o), 0 0 30px var(--color-o), 0 0 35px var(--color-o);
            }
            20%, 24%, 55% { text-shadow: none; }
        }
        @keyframes gradientShift { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        h1 {
            font-size: clamp(2.5rem, 10vw, 4rem); margin-bottom: 2rem;
            color: var(--text-color);
            animation: neonFlicker 5s infinite linear;
        }
        .btn {
            font-family: 'Orbitron', sans-serif; font-weight: 700;
            font-size: clamp(1rem, 4vw, 1.2rem); padding: 16px 32px;
            margin: 10px; cursor: pointer; border-radius: 10px;
            transition: transform 0.2s var(--fast-bezier), box-shadow 0.2s var(--fast-bezier), background-color 0.2s var(--fast-bezier);
            width: 80%; max-width: 300px;
            background: transparent; border: 2px solid; text-shadow: 0 0 8px;
            box-shadow: inset 0 0 10px 0px, 0 0 10px 0px;
            position: relative;
            z-index: 1;
        }
        .btn-primary { color: var(--color-x); border-color: var(--color-x); }
        .btn-primary:hover, .btn-primary:focus { color: var(--background-color); background-color: var(--color-x); box-shadow: 0 0 20px var(--color-x), 0 0 35px var(--color-x); transform: translateY(-4px) scale(1.02); outline: none; }
        .btn-secondary { color: var(--color-o); border-color: var(--color-o); }
        .btn-secondary:hover, .btn-secondary:focus { color: var(--background-color); background-color: var(--color-o); box-shadow: 0 0 20px var(--color-o), 0 0 35px var(--color-o); transform: translateY(-4px) scale(1.02); outline: none; }
        .btn:active {
            transform: translateY(0px) scale(0.96);
            filter: brightness(1.1);
        }
        .btn.btn-header {
            width: auto;
            padding: 8px 16px;
            font-size: 0.9rem;
        }
        #shatter-container {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            pointer-events: none; z-index: 9999;
        }
        .shard {
            position: absolute;
            transform-origin: center;
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
            animation: shatter 0.7s ease-out forwards;
        }
        @keyframes shatter {
            0% { transform: translate(0, 0) rotate(0deg) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) rotate(var(--rot)) scale(0); opacity: 0; }
        }
        .game-header { width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .score-display, .turn-display { font-size: 1.5rem; padding: 5px 15px; border-radius: 8px; }
        .score-display { text-shadow: 0 0 5px var(--text-color); }
        .score-display .score { display: inline-block; transition: transform 0.3s var(--fast-bezier); }
        .score-display .score.updated { animation: scoreUpdate 0.4s var(--fast-bezier); }
        .turn-display { transition: color 0.3s, text-shadow 0.3s; }
        .turn-display.x { color: var(--color-x); text-shadow: 0 0 10px var(--color-x); }
        .turn-display.o { color: var(--color-o); text-shadow: 0 0 10px var(--color-o); }
        .game-board-container { position: relative; }
        #gameBoard {
            display: grid; --cell-size: clamp(80px, 25vw, 110px);
            grid-template-columns: repeat(3, var(--cell-size)); grid-template-rows: repeat(3, var(--cell-size));
            gap: 8px; background-color: var(--grid-color); border: 2px solid var(--grid-color);
            box-shadow: 0 0 20px var(--grid-color), inset 0 0 10px var(--grid-color);
            border-radius: 10px; transition: filter 0.3s;
        }
        .cell {
            background-color: var(--background-color); border-radius: 4px; display: flex;
            justify-content: center; align-items: center; font-size: calc(var(--cell-size) * 0.8);
            cursor: pointer; transition: background-color 0.2s;
        }
        #gameBoard.turn-x .cell:not(.x):not(.o):hover { background-color: #3d0f31; }
        #gameBoard.turn-o .cell:not(.x):not(.o):hover { background-color: #0c324e; }
        .cell.x::before, .cell.o::before { animation: popIn 0.3s var(--fast-bezier); }
        .cell.x::before { content: 'X'; color: var(--color-x); text-shadow: 0 0 5px, 0 0 15px, 0 0 30px; }
        .cell.o::before { content: 'O'; color: var(--color-o); text-shadow: 0 0 5px, 0 0 15px, 0 0 30px; }
        .cell.winning-cell { animation: pulse 1s ease-in-out infinite; }
        #winning-line { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; visibility: hidden; }
        #winning-line .line { stroke-width: 8px; stroke-linecap: round; stroke-dasharray: 1000; stroke-dashoffset: 1000; animation: drawLine 0.8s ease-out forwards; }
        .overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--overlay-color);
            backdrop-filter: blur(8px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transform: scale(1.05);
            transition: opacity 0.3s var(--fast-bezier), transform 0.3s var(--fast-bezier); 
            z-index: 100;
        }
        .overlay.active { opacity: 1; pointer-events: all; transform: scale(1); }
        .overlay-text { font-size: clamp(2rem, 8vw, 2.5rem); margin-bottom: 1.5rem; text-shadow: 0 0 10px #fff;}
        #winningMessage-text { font-size: clamp(3rem, 12vw, 5rem); text-shadow: 0 0 10px #fff, 0 0 40px var(--color-x); margin-bottom: 1rem; }
        #ai-thinking-text { font-size: 2rem; color: var(--color-o); text-shadow: 0 0 10px var(--color-o); }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
    </style>
</head>
<body>
    <div id="aria-live-region" class="sr-only" aria-live="polite"></div>
    <div id="shatter-container"></div>
    <div class="app-container">
        <button id="universalBackButton" class="btn btn-secondary" style="display: none;" aria-label="Go back">Back</button>
        <div id="mainMenu" class="view active">
            <h1>Pro Tic Tac Toe</h1>
            <button id="pvcButton" class="btn btn-primary">Player vs AI</button>
            <button id="pvpButton" class="btn btn-primary">Player vs Player</button>
        </div>
        <div id="symbolSelection" class="view">
            <h1>Choose Your Mark</h1>
            <button class="btn btn-secondary symbol-choice" data-symbol="x">Play as X</button>
            <button class="btn btn-secondary symbol-choice" data-symbol="o">Play as O</button>
        </div>
        <div id="difficultySelection" class="view">
            <h1>Select Difficulty</h1>
            <button id="easyButton" class="btn btn-secondary" data-difficulty="easy">Easy</button>
            <button id="hardButton" class="btn btn-secondary" data-difficulty="hard">Hard</button>
        </div>
        <div id="gameScreen" class="view">
            <div class="game-header">
                <div id="score-display" class="score-display" aria-live="polite"></div>
                <div id="turn-display" class="turn-display"></div>
            </div>
            <div class="game-board-container">
                <div id="gameBoard" role="grid">
                    <div class="cell" role="gridcell" data-cell-index="0"></div><div class="cell" role="gridcell" data-cell-index="1"></div><div class="cell" role="gridcell" data-cell-index="2"></div>
                    <div class="cell" role="gridcell" data-cell-index="3"></div><div class="cell" role="gridcell" data-cell-index="4"></div><div class="cell" role="gridcell" data-cell-index="5"></div>
                    <div class="cell" role="gridcell" data-cell-index="6"></div><div class="cell" role="gridcell" data-cell-index="7"></div><div class="cell" role="gridcell" data-cell-index="8"></div>
                </div>
                <svg id="winning-line"><line class="line" x1="0" y1="0" x2="0" y2="0"/></svg>
            </div>
        </div>
        <div id="winningMessage" class="overlay">
            <div id="winningMessage-text"></div>
            <button id="restartButton" class="btn btn-primary">Play Again</button>
        </div>
        <div id="aiThinkingOverlay" class="overlay">
            <div id="ai-thinking-text">AI is thinking...</div>
        </div>
        <div id="exitConfirmationOverlay" class="overlay">
            <div class="overlay-text">Exit current match?</div>
            <button id="confirmExitButton" class="btn btn-primary">Yes, Exit</button>
            <button id="cancelExitButton" class="btn btn-secondary">No, Stay</button>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const X_CLASS = 'x';
            const O_CLASS = 'o';
            const WINNING_COMBINATIONS = [
                { combo: [0, 1, 2], name: 'h1' }, { combo: [3, 4, 5], name: 'h2' }, { combo: [6, 7, 8], name: 'h3' },
                { combo: [0, 3, 6], name: 'v1' }, { combo: [1, 4, 7], name: 'v2' }, { combo: [2, 5, 8], name: 'v3' },
                { combo: [0, 4, 8], name: 'd1' }, { combo: [2, 4, 6], name: 'd2' }
            ];
            const dom = {
                views: document.querySelectorAll('.view'),
                cellElements: document.querySelectorAll('[data-cell-index]'),
                gameBoard: document.getElementById('gameBoard'),
                overlays: {
                    winning: document.getElementById('winningMessage'),
                    aiThinking: document.getElementById('aiThinkingOverlay'),
                    exitConfirmation: document.getElementById('exitConfirmationOverlay')
                },
                winningMessageText: document.getElementById('winningMessage-text'),
                winningLine: {
                    svg: document.getElementById('winning-line'),
                    line: document.querySelector('#winning-line .line')
                },
                displays: {
                    score: document.getElementById('score-display'),
                    turn: document.getElementById('turn-display')
                },
                buttons: {
                    pvc: document.getElementById('pvcButton'),
                    pvp: document.getElementById('pvpButton'),
                    symbolChoices: document.querySelectorAll('.symbol-choice'),
                    easy: document.getElementById('easyButton'),
                    hard: document.getElementById('hardButton'),
                    restart: document.getElementById('restartButton'),
                    universalBack: document.getElementById('universalBackButton'),
                    confirmExit: document.getElementById('confirmExitButton'),
                    cancelExit: document.getElementById('cancelExitButton')
                },
                ariaLiveRegion: document.getElementById('aria-live-region')
            };
            const state = {
                gameMode: 'pvp',
                difficulty: 'hard',
                playerMark: X_CLASS,
                aiMark: O_CLASS,
                isOTurn: false,
                board: Array(9).fill(null),
                score: { x: 0, o: 0 },
                isGameActive: false,
                gamesPlayed: 0,
                nextMistakeGame: 0
            };
            const effects = {
                createShatter(x, y, color) {
                    const container = document.getElementById('shatter-container');
                    for (let i = 0; i < 15; i++) {
                        const shard = document.createElement('div');
                        shard.classList.add('shard');
                        const size = Math.random() * 12 + 5;
                        shard.style.setProperty('--tx', `${(Math.random() * 250 - 125)}px`);
                        shard.style.setProperty('--ty', `${(Math.random() * 250 - 125)}px`);
                        shard.style.setProperty('--rot', `${(Math.random() * 540 - 270)}deg`);
                        shard.style.width = `${size}px`;
                        shard.style.height = `${size}px`;
                        shard.style.top = `${y}px`;
                        shard.style.left = `${x}px`;
                        shard.style.backgroundColor = color;
                        container.appendChild(shard);
                        setTimeout(() => shard.remove(), 700);
                    }
                }
            };
            const ui = {
                toggleOverlay: (overlay, show) => overlay.classList.toggle('active', show),
                showView(viewId) {
                    const backButton = dom.buttons.universalBack;
                    const activeView = document.getElementById(viewId);
                    dom.views.forEach(view => view.classList.remove('active'));
                    activeView.classList.add('active');
                    let backTarget = null;
                    let isGameScreen = false;
                    switch (viewId) {
                        case 'mainMenu':
                            state.score = { x: 0, o: 0 }; state.gamesPlayed = 0; state.nextMistakeGame = Math.floor(Math.random() * 3) + 3;
                            break;
                        case 'symbolSelection': backTarget = 'mainMenu'; break;
                        case 'difficultySelection': backTarget = 'symbolSelection'; break;
                        case 'gameScreen':
                            backTarget = state.gameMode === 'pvp' ? 'mainMenu' : 'difficultySelection'; isGameScreen = true; game.start();
                            break;
                    }
                    if (backTarget) {
                        backButton.style.display = 'block'; backButton.dataset.target = backTarget;
                        backButton.classList.toggle('btn-header', isGameScreen);
                        if (isGameScreen) { document.querySelector('.game-header').prepend(backButton); }
                        else { activeView.appendChild(backButton); }
                    } else { backButton.style.display = 'none'; }
                },
                update() { this.updateBoard(); this.updateTurnIndicator(); this.updateScoreDisplay(); },
                updateBoard() { dom.cellElements.forEach((cell, index) => { cell.className = 'cell'; if (state.board[index]) cell.classList.add(state.board[index]); }); },
                updateTurnIndicator() {
                    const currentClass = state.isOTurn ? O_CLASS : X_CLASS;
                    dom.displays.turn.innerText = `${currentClass.toUpperCase()}'s Turn`;
                    dom.displays.turn.className = `turn-display ${currentClass}`;
                    dom.gameBoard.className = `turn-${currentClass}`;
                },
                updateScoreDisplay() { dom.displays.score.innerHTML = `X: <span class="score" id="score-x">${state.score.x}</span> | O: <span class="score" id="score-o">${state.score.o}</span>`; },
                flashScore(winner) { const scoreSpan = document.getElementById(`score-${winner}`); if (scoreSpan) { scoreSpan.classList.add('updated'); setTimeout(() => scoreSpan.classList.remove('updated'), 400); } },
                drawWinningLine(winningItem) {
                    const boardRect = dom.gameBoard.getBoundingClientRect(); const cellSize = boardRect.width / 3; const halfCell = cellSize / 2;
                    const coords = {
                        h1:{x1:halfCell,y1:halfCell,x2:boardRect.width-halfCell,y2:halfCell},h2:{x1:halfCell,y1:cellSize+halfCell,x2:boardRect.width-halfCell,y2:cellSize+halfCell},h3:{x1:halfCell,y1:cellSize*2+halfCell,x2:boardRect.width-halfCell,y2:cellSize*2+halfCell},
                        v1:{x1:halfCell,y1:halfCell,x2:halfCell,y2:boardRect.height-halfCell},v2:{x1:cellSize+halfCell,y1:halfCell,x2:cellSize+halfCell,y2:boardRect.height-halfCell},v3:{x1:cellSize*2+halfCell,y1:halfCell,x2:cellSize*2+halfCell,y2:boardRect.height-halfCell},
                        d1:{x1:halfCell,y1:halfCell,x2:boardRect.width-halfCell,y2:boardRect.height-halfCell},d2:{x1:boardRect.width-halfCell,y1:halfCell,x2:halfCell,y2:boardRect.height-halfCell}
                    };
                    const pos = coords[winningItem.name]; const winnerColor = state.isOTurn ? 'var(--color-o)' : 'var(--color-x)';
                    const line = dom.winningLine.line; line.setAttribute('x1',pos.x1);line.setAttribute('y1',pos.y1);line.setAttribute('x2',pos.x2);line.setAttribute('y2',pos.y2);
                    line.style.stroke = winnerColor; dom.winningLine.svg.style.visibility = 'visible';
                    winningItem.combo.forEach(index => dom.cellElements[index].classList.add('winning-cell'));
                },
                showEndGameMessage(draw) {
                    let message = draw ? 'Draw!' : `${state.isOTurn ? 'O' : 'X'} Wins!`;
                    dom.winningMessageText.innerText = message; this.toggleOverlay(dom.overlays.winning, true);
                    this.announce(message + " Press Play Again to continue.");
                },
                announce: (message) => dom.ariaLiveRegion.textContent = message
            };
            const game = {
                start() {
                    state.isGameActive = true; state.isOTurn = false; state.board.fill(null);
                    ui.toggleOverlay(dom.overlays.winning, false); dom.winningLine.svg.style.visibility = 'hidden';
                    dom.gameBoard.style.pointerEvents = 'auto'; ui.update();
                    ui.announce(`New game started. X's turn.`);
                    if (state.gameMode === 'pvc' && state.playerMark === O_CLASS) this.triggerAIMove();
                },
                handleCellClick(e) {
                    if (!e.target.matches('[data-cell-index]')) return;
                    const index = parseInt(e.target.dataset.cellIndex);
                    if (!state.isGameActive || state.board[index] !== null) return;
                    const currentClass = state.isOTurn ? O_CLASS : X_CLASS;
                    if (state.gameMode === 'pvc' && currentClass === state.aiMark) return;
                    this.placeMark(index, currentClass); ui.announce(`${currentClass.toUpperCase()} placed in cell ${index + 1}`);
                    if (this.processMove(currentClass)) return;
                    if (state.gameMode === 'pvc') this.triggerAIMove();
                },
                placeMark(index, currentClass) { state.board[index] = currentClass; ui.updateBoard(); },
                swapTurns() { state.isOTurn = !state.isOTurn; ui.updateTurnIndicator(); ui.announce(`${state.isOTurn ? 'O' : 'X'}'s turn.`); },
                processMove(currentClass) {
                    const winningCombination = this.checkWin(currentClass);
                    if (winningCombination) { this.end(false, winningCombination); return true; }
                    if (this.isDraw()) { this.end(true); return true; }
                    this.swapTurns(); return false;
                },
                triggerAIMove() {
                    ui.toggleOverlay(dom.overlays.aiThinking, true);
                    setTimeout(() => { ai.move(); ui.toggleOverlay(dom.overlays.aiThinking, false); }, Math.random() * 250 + 200);
                },
                end(draw, winningCombination = null) {
                    state.isGameActive = false; dom.gameBoard.style.pointerEvents = 'none';
                    if (!draw) {
                        const winner = state.isOTurn ? O_CLASS : X_CLASS; state.score[winner]++;
                        ui.updateScoreDisplay(); ui.flashScore(winner); ui.drawWinningLine(winningCombination);
                    }
                    if (state.gameMode === 'pvc') state.gamesPlayed++;
                    setTimeout(() => ui.showEndGameMessage(draw), winningCombination ? 800 : 100);
                },
                checkWin: (player, board = state.board) => WINNING_COMBINATIONS.find(item => item.combo.every(index => board[index] === player)),
                isDraw: () => state.board.every(cell => cell !== null)
            };
            const ai = {
                move() {
                    if (!state.isGameActive) return;
                    if (state.difficulty === 'easy') {
                        const emptyCells = state.board.map((v, i) => v === null ? i : null).filter(v => v !== null);
                        if(emptyCells.length > 0) {
                            const randomIndex = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                            game.placeMark(randomIndex, state.aiMark); this.announceMove(randomIndex); game.processMove(state.aiMark);
                        }
                        return;
                    }
                    const isMistakeTime = state.gamesPlayed >= state.nextMistakeGame;
                    const aiWinningMove = this.findWinningMove(state.aiMark);
                    if (aiWinningMove !== null) { game.placeMark(aiWinningMove, state.aiMark); this.announceMove(aiWinningMove); game.processMove(state.aiMark); return; }
                    const playerWinningMove = this.findWinningMove(state.playerMark);
                    if (playerWinningMove !== null) {
                        if (isMistakeTime) {
                            const alternativeMove = this.findPlausibleAlternativeMove(playerWinningMove);
                            game.placeMark(alternativeMove, state.aiMark); this.announceMove(alternativeMove);
                            state.nextMistakeGame = state.gamesPlayed + Math.floor(Math.random() * 3) + 3;
                        } else { game.placeMark(playerWinningMove, state.aiMark); this.announceMove(playerWinningMove); }
                        game.processMove(state.aiMark); return;
                    }
                    // --- BUG FIX IS HERE ---
                    // Pass a *copy* of the board to the AI's thinking process to prevent it from breaking the live game.
                    const bestMove = this.minimax([...state.board], state.aiMark).index;
                    game.placeMark(bestMove, state.aiMark); this.announceMove(bestMove); game.processMove(state.aiMark);
                },
                announceMove: (index) => ui.announce(`AI placed ${state.aiMark.toUpperCase()} in cell ${index + 1}`),
                findWinningMove(player) {
                    for (let i = 0; i < 9; i++) {
                        if (state.board[i] === null) {
                            const tempBoard = [...state.board]; tempBoard[i] = player;
                            if (game.checkWin(player, tempBoard)) return i;
                        }
                    }
                    return null;
                },
                findPlausibleAlternativeMove(blockingMoveIndex) {
                    const availableSpots = state.board.map((v, i) => v === null ? i : null).filter(v => v !== null);
                    const alternatives = availableSpots.filter(index => index !== blockingMoveIndex);
                    return alternatives.length > 0 ? alternatives[Math.floor(Math.random() * alternatives.length)] : blockingMoveIndex;
                },
                minimax(newBoard, player) {
                    const availableSpots = newBoard.map((v, i) => v === null ? i : null).filter(v => v !== null);
                    if (game.checkWin(state.playerMark, newBoard)) return { score: -10 };
                    if (game.checkWin(state.aiMark, newBoard)) return { score: 10 };
                    if (availableSpots.length === 0) return { score: 0 };
                    const moves = [];
                    for (let i = 0; i < availableSpots.length; i++) {
                        const move = {};
                        move.index = availableSpots[i];
                        newBoard[availableSpots[i]] = player;
                        if (player === state.aiMark) {
                            const result = this.minimax(newBoard, state.playerMark);
                            move.score = result.score;
                        } else {
                            const result = this.minimax(newBoard, state.aiMark);
                            move.score = result.score;
                        }
                        newBoard[availableSpots[i]] = null;
                        moves.push(move);
                    }
                    let bestMove;
                    if (player === state.aiMark) {
                        let bestScore = -10000;
                        for (let i = 0; i < moves.length; i++) {
                            if (moves[i].score > bestScore) { bestScore = moves[i].score; bestMove = moves[i]; }
                        }
                    } else {
                        let bestScore = 10000;
                        for (let i = 0; i < moves.length; i++) {
                            if (moves[i].score < bestScore) { bestScore = moves[i].score; bestMove = moves[i]; }
                        }
                    }
                    return bestMove;
                }
            };
            function setupEventListeners() {
                dom.buttons.pvp.addEventListener('click', () => { state.gameMode = 'pvp'; ui.showView('gameScreen'); });
                dom.buttons.pvc.addEventListener('click', () => { state.gameMode = 'pvc'; ui.showView('symbolSelection'); });
                dom.buttons.symbolChoices.forEach(btn => btn.addEventListener('click', (e) => {
                    state.playerMark = e.target.dataset.symbol;
                    state.aiMark = state.playerMark === X_CLASS ? O_CLASS : X_CLASS;
                    ui.showView('difficultySelection');
                }));
                [dom.buttons.easy, dom.buttons.hard].forEach(btn => btn.addEventListener('click', (e) => {
                    state.difficulty = e.target.dataset.difficulty;
                    ui.showView('gameScreen');
                }));
                dom.buttons.universalBack.addEventListener('click', (e) => {
                    const targetViewId = e.target.dataset.target;
                    if (state.isGameActive && document.getElementById('gameScreen').classList.contains('active')) {
                        dom.overlays.exitConfirmation.dataset.target = targetViewId;
                        ui.toggleOverlay(dom.overlays.exitConfirmation, true);
                    } else { ui.showView(targetViewId); }
                });
                dom.buttons.cancelExit.addEventListener('click', () => ui.toggleOverlay(dom.overlays.exitConfirmation, false));
                dom.buttons.confirmExit.addEventListener('click', () => {
                    const targetViewId = dom.overlays.exitConfirmation.dataset.target;
                    state.isGameActive = false; ui.toggleOverlay(dom.overlays.exitConfirmation, false);
                    ui.showView(targetViewId);
                });
                dom.buttons.restart.addEventListener('click', () => game.start());
                dom.gameBoard.addEventListener('click', game.handleCellClick.bind(game));
                document.querySelectorAll('.btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const colorVar = button.classList.contains('btn-secondary') ? '--color-o' : '--color-x';
                        const shatterColor = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim();
                        effects.createShatter(e.clientX, e.clientY, shatterColor);
                    });
                });
            }
            setupEventListeners();
            ui.showView('mainMenu');
        });
    </script>
</body>
</html>
