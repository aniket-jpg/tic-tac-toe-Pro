<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <base target="_top">
    <title>Neon Tic Tac Toe Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --background-color: #0d0221; --grid-color: #ff00ff; --color-o: #00d9ff; --color-x: #ff1b8d;
            --text-color: #f5f5f5; --overlay-color: rgba(13, 2, 33, 0.75); --bg-grad-1: #0d0221;
            --bg-grad-2: #240b36; --fast-bezier: cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        html, body {
            height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: 'Orbitron', sans-serif;
            background: linear-gradient(45deg, var(--bg-grad-1), var(--bg-grad-2));
            background-size: 200% 200%; animation: gradientShift 15s ease infinite;
            color: var(--text-color); -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
        }
        .app-container {
            width: 100%; height: 100%; max-width: 500px; margin: 0 auto; display: flex; flex-direction: column;
            justify-content: center; align-items: center; padding: 20px; box-sizing: border-box; position: relative;
        }
        .view {
            width: 100%; height: 100%; display: none; flex-direction: column;
            justify-content: center; align-items: center; text-align: center; animation: fadeIn 0.4s var(--fast-bezier);
        }
        .view.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.97); } to { opacity: 1; transform: scale(1); } }
        @keyframes popIn { 0% { opacity: 0; transform: scale(0.6); } 100% { opacity: 1; transform: scale(1); } }
        @keyframes drawLine { to { stroke-dashoffset: 0; } }
        @keyframes pulse { 0%, 100% { transform: scale(1); box-shadow: 0 0 10px, 0 0 20px; } 50% { transform: scale(1.05); box-shadow: 0 0 20px, 0 0 40px; } }
        @keyframes scoreUpdate { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.25); } }
        @keyframes neonFlicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px var(--color-o), 0 0 20px var(--color-o), 0 0 25px var(--color-o), 0 0 30px var(--color-o), 0 0 35px var(--color-o); }
            20%, 24%, 55% { text-shadow: none; }
        }
        @keyframes gradientShift { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        h1 { font-size: clamp(2.5rem, 10vw, 4rem); margin-bottom: 2rem; color: var(--text-color); animation: neonFlicker 5s infinite linear; }
        .btn {
            font-family: 'Orbitron', sans-serif; font-weight: 700; font-size: clamp(1rem, 4vw, 1.2rem); padding: 16px 32px;
            margin: 10px; cursor: pointer; border-radius: 10px;
            transition: transform 0.2s var(--fast-bezier), box-shadow 0.2s var(--fast-bezier), background-color 0.2s var(--fast-bezier);
            width: 80%; max-width: 300px; background: transparent; border: 2px solid; text-shadow: 0 0 8px;
            box-shadow: inset 0 0 10px 0px, 0 0 10px 0px; position: relative; z-index: 1;
        }
        .btn-primary { color: var(--color-x); border-color: var(--color-x); }
        .btn-primary:hover, .btn-primary:focus { color: var(--background-color); background-color: var(--color-x); box-shadow: 0 0 20px var(--color-x), 0 0 35px var(--color-x); transform: translateY(-4px) scale(1.02); outline: none; }
        .btn-secondary { color: var(--color-o); border-color: var(--color-o); }
        .btn-secondary:hover, .btn-secondary:focus { color: var(--background-color); background-color: var(--color-o); box-shadow: 0 0 20px var(--color-o), 0 0 35px var(--color-o); transform: translateY(-4px) scale(1.02); outline: none; }
        .btn:active { transform: translateY(0px) scale(0.96); filter: brightness(1.1); }
        .btn.btn-header { width: auto; padding: 8px 16px; font-size: 0.9rem; }
        #shatter-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 9999; }
        .shard { position: absolute; transform-origin: center; clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); animation: shatter 0.7s ease-out forwards; }
        @keyframes shatter { 0% { transform: translate(0, 0) rotate(0deg) scale(1); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) rotate(var(--rot)) scale(0); opacity: 0; } }
        .game-header { width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; }
        .score-display, .turn-display { font-size: 1.5rem; padding: 5px 15px; border-radius: 8px; }
        .score-display { text-shadow: 0 0 5px var(--text-color); }
        .score-display .score { display: inline-block; transition: transform 0.3s var(--fast-bezier); }
        .score-display .score.updated { animation: scoreUpdate 0.4s var(--fast-bezier); }
        .turn-display { transition: color 0.3s, text-shadow 0.3s; }
        .turn-display.x { color: var(--color-x); text-shadow: 0 0 10px var(--color-x); }
        .turn-display.o { color: var(--color-o); text-shadow: 0 0 10px var(--color-o); }
        .game-board-container { position: relative; }
        #gameBoard {
            display: grid; --cell-size: clamp(80px, 25vw, 110px);
            grid-template-columns: repeat(3, var(--cell-size)); grid-template-rows: repeat(3, var(--cell-size));
            gap: 8px; background-color: var(--grid-color); border: 2px solid var(--grid-color);
            box-shadow: 0 0 20px var(--grid-color), inset 0 0 10px var(--grid-color);
            border-radius: 10px; transition: filter 0.3s;
        }
        .cell {
            background-color: var(--background-color); border-radius: 4px; display: flex;
            justify-content: center; align-items: center; font-size: calc(var(--cell-size) * 0.8);
            cursor: pointer; transition: background-color 0.2s;
        }
        #gameBoard.turn-x .cell:not(.x):not(.o):hover { background-color: #3d0f31; }
        #gameBoard.turn-o .cell:not(.x):not(.o):hover { background-color: #0c324e; }
        .cell.x::before, .cell.o::before { animation: popIn 0.3s var(--fast-bezier); }
        .cell.x::before { content: 'X'; color: var(--color-x); text-shadow: 0 0 5px, 0 0 15px, 0 0 30px; }
        .cell.o::before { content: 'O'; color: var(--color-o); text-shadow: 0 0 5px, 0 0 15px, 0 0 30px; }
        .cell.winning-cell { animation: pulse 1s ease-in-out infinite; }
        #winning-line { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; visibility: hidden; }
        #winning-line .line { stroke-width: 8px; stroke-linecap: round; stroke-dasharray: 1000; stroke-dashoffset: 1000; animation: drawLine 0.8s ease-out forwards; }
        .overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--overlay-color);
            backdrop-filter: blur(8px); display: flex; flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transform: scale(1.05);
            transition: opacity 0.3s var(--fast-bezier), transform 0.3s var(--fast-bezier); z-index: 100;
        }
        .overlay.active { opacity: 1; pointer-events: all; transform: scale(1); }
        .overlay-text { font-size: clamp(2rem, 8vw, 2.5rem); margin-bottom: 1.5rem; text-shadow: 0 0 10px #fff; }
        #winningMessage-text { font-size: clamp(3rem, 12vw, 5rem); text-shadow: 0 0 10px #fff, 0 0 40px var(--color-x); margin-bottom: 1rem; }
        #ai-thinking-text { font-size: 2rem; color: var(--color-o); text-shadow: 0 0 10px var(--color-o); }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }
    </style>
</head>
<body>
    <!-- Sound Elements -->
    <audio id="bgMusic" src="sounds/bg-music.mp3" loop></audio>
    <audio id="clickSound" src="sounds/click.mp3"></audio>
    <audio id="winSound" src="sounds/win.mp3"></audio>

    <div id="aria-live-region" class="sr-only" aria-live="polite"></div>
    <div id="shatter-container"></div>
    <div class="app-container">
        <!-- Universal Buttons: Moved by JavaScript -->
        <button id="soundToggle" class="btn btn-secondary">ðŸ”Š Sound On</button>
        <button id="universalBackButton" class="btn btn-secondary" style="display: none;" aria-label="Go back">Back</button>

        <div id="mainMenu" class="view active">
            <h1>Pro Tic Tac Toe</h1>
            <button id="pvcButton" class="btn btn-primary">Player vs AI</button>
            <button id="pvpButton" class="btn btn-primary">Player vs Player</button>
        </div>
        <div id="difficultySelection" class="view">
            <h1>Select Difficulty</h1>
            <button id="easyButton" class="btn btn-secondary" data-difficulty="easy">Easy</button>
            <button id="hardButton" class="btn btn-secondary" data-difficulty="hard">Hard</button>
        </div>
        <div id="gameScreen" class="view">
            <div class="game-header">
                <div id="score-display" class="score-display" aria-live="polite"></div>
                <div id="turn-display" class="turn-display"></div>
            </div>
            <div class="game-board-container">
                <div id="gameBoard" role="grid">
                    <div class="cell" role="gridcell" data-cell-index="0"></div><div class="cell" role="gridcell" data-cell-index="1"></div><div class="cell" role="gridcell" data-cell-index="2"></div>
                    <div class="cell" role="gridcell" data-cell-index="3"></div><div class="cell" role="gridcell" data-cell-index="4"></div><div class="cell" role="gridcell" data-cell-index="5"></div>
                    <div class="cell" role="gridcell" data-cell-index="6"></div><div class="cell" role="gridcell" data-cell-index="7"></div><div class="cell" role="gridcell" data-cell-index="8"></div>
                </div>
                <svg id="winning-line"><line class="line" x1="0" y1="0" x2="0" y2="0"/></svg>
            </div>
        </div>
        <div id="winningMessage" class="overlay">
            <div id="winningMessage-text"></div>
            <button id="restartButton" class="btn btn-primary">Play Again</button>
        </div>
        <div id="aiThinkingOverlay" class="overlay">
            <div id="ai-thinking-text">AI is thinking...</div>
        </div>
        <div id="exitConfirmationOverlay" class="overlay">
            <div class="overlay-text">Exit current match?</div>
            <button id="confirmExitButton" class="btn btn-primary">Yes, Exit</button>
            <button id="cancelExitButton" class="btn btn-secondary">No, Stay</button>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const X_CLASS = 'x';
            const O_CLASS = 'o';
            const WINNING_COMBINATIONS = [
                { combo: [0, 1, 2], name: 'h1' }, { combo: [3, 4, 5], name: 'h2' }, { combo: [6, 7, 8], name: 'h3' },
                { combo: [0, 3, 6], name: 'v1' }, { combo: [1, 4, 7], name: 'v2' }, { combo: [2, 5, 8], name: 'v3' },
                { combo: [0, 4, 8], name: 'd1' }, { combo: [2, 4, 6], name: 'd2' }
            ];
            const dom = {
                views: document.querySelectorAll('.view'),
                cellElements: document.querySelectorAll('[data-cell-index]'),
                gameBoard: document.getElementById('gameBoard'),
                overlays: { winning: document.getElementById('winningMessage'), aiThinking: document.getElementById('aiThinkingOverlay'), exitConfirmation: document.getElementById('exitConfirmationOverlay') },
                winningMessageText: document.getElementById('winningMessage-text'),
                winningLine: { svg: document.getElementById('winning-line'), line: document.querySelector('#winning-line .line') },
                displays: { score: document.getElementById('score-display'), turn: document.getElementById('turn-display') },
                sounds: { bgMusic: document.getElementById('bgMusic'), click: document.getElementById('clickSound'), win: document.getElementById('winSound') },
                buttons: {
                    pvc: document.getElementById('pvcButton'), pvp: document.getElementById('pvpButton'),
                    easy: document.getElementById('easyButton'), hard: document.getElementById('hardButton'),
                    restart: document.getElementById('restartButton'), universalBack: document.getElementById('universalBackButton'),
                    confirmExit: document.getElementById('confirmExitButton'), cancelExit: document.getElementById('cancelExitButton'),
                    soundToggle: document.getElementById('soundToggle')
                },
                ariaLiveRegion: document.getElementById('aria-live-region')
            };
            const state = {
                gameMode: 'pvp', difficulty: 'hard', playerMark: X_CLASS, aiMark: O_CLASS, 
                isPlayerTurnToStart: true, isOTurn: false, board: Array(9).fill(null),
                score: { player: 0, ai: 0 }, isGameActive: false, soundOn: true
            };
            const audio = {
                targetVolume: 0.3,
                fadeInterval: null,
                playClick() { if (!state.soundOn) return; dom.sounds.click.currentTime = 0; dom.sounds.click.play().catch(()=>{}); },
                playWin() { if (!state.soundOn) return; dom.sounds.win.currentTime = 0; dom.sounds.win.play().catch(()=>{}); },
                fadeInMusic() {
                    const music = dom.sounds.bgMusic;
                    if (!state.soundOn || this.fadeInterval || !music.paused) return;
                    music.volume = 0;
                    const promise = music.play();
                    if (promise !== undefined) {
                        promise.then(() => {
                            this.fadeInterval = setInterval(() => {
                                let newVolume = music.volume + 0.05;
                                if (newVolume >= this.targetVolume) {
                                    music.volume = this.targetVolume;
                                    clearInterval(this.fadeInterval); this.fadeInterval = null;
                                } else { music.volume = newVolume; }
                            }, 100);
                        }).catch(() => {
                            document.body.addEventListener('click', () => this.fadeInMusic(), { once: true });
                        });
                    }
                },
                pauseMusic() {
                    clearInterval(this.fadeInterval); this.fadeInterval = null;
                    const music = dom.sounds.bgMusic;
                    if (music.paused) return;
                    const fadeOutInterval = setInterval(() => {
                        let newVolume = music.volume - 0.05;
                        if (newVolume <= 0) {
                            music.volume = 0; music.pause(); clearInterval(fadeOutInterval);
                        } else { music.volume = newVolume; }
                    }, 50);
                },
                updateMusicState() {
                    const isMenuScreen = !document.getElementById('gameScreen').classList.contains('active');
                    if (state.soundOn && isMenuScreen) {
                        this.fadeInMusic();
                    } else {
                        this.pauseMusic();
                    }
                }
            };
            const ui = {
                toggleOverlay: (overlay, show) => overlay.classList.toggle('active', show),
                showView(viewId) {
                    const backButton = dom.buttons.universalBack;
                    const soundButton = dom.buttons.soundToggle;
                    const activeView = document.getElementById(viewId);
                    dom.views.forEach(view => view.classList.remove('active'));
                    activeView.classList.add('active');

                    audio.updateMusicState();

                    let backTarget = null; let isGameScreen = false;
                    switch (viewId) {
                        case 'mainMenu': state.score = { player: 0, ai: 0 }; state.isPlayerTurnToStart = true; break;
                        case 'difficultySelection': backTarget = 'mainMenu'; break;
                        case 'gameScreen': backTarget = (state.gameMode === 'pvp') ? 'mainMenu' : 'difficultySelection'; isGameScreen = true; game.start(); break;
                    }
                    if (backTarget) {
                        backButton.style.display = 'block'; backButton.dataset.target = backTarget;
                        backButton.classList.toggle('btn-header', isGameScreen);
                        if (isGameScreen) { document.querySelector('.game-header').prepend(backButton); } else { activeView.appendChild(backButton); }
                    } else { backButton.style.display = 'none'; }
                    
                    if (['mainMenu', 'difficultySelection'].includes(viewId)) {
                        soundButton.style.display = 'block'; activeView.appendChild(soundButton); soundButton.classList.remove('btn-header');
                    } else if (isGameScreen) {
                        soundButton.style.display = 'block'; document.querySelector('.game-header').appendChild(soundButton); soundButton.classList.add('btn-header');
                    } else { soundButton.style.display = 'none'; }
                },
                update() { this.updateBoard(); this.updateTurnIndicator(); this.updateScoreDisplay(); },
                updateBoard() { dom.cellElements.forEach((cell, index) => { cell.className = 'cell'; if (state.board[index]) cell.classList.add(state.board[index]); }); },
                updateTurnIndicator() {
                    const currentClass = state.isOTurn ? O_CLASS : X_CLASS;
                    dom.displays.turn.innerText = `${currentClass.toUpperCase()}'s Turn`;
                    dom.displays.turn.className = `turn-display ${currentClass}`; dom.gameBoard.className = `turn-${currentClass}`;
                },
                updateScoreDisplay() { dom.displays.score.innerHTML = `You: <span class="score">${state.score.player}</span> | AI: <span class="score">${state.score.ai}</span>`; },
                flashScore(winnerMark) { const scoreSpans = dom.displays.score.querySelectorAll('.score'); if(winnerMark === state.playerMark) { scoreSpans[0].classList.add('updated'); } else { scoreSpans[1].classList.add('updated'); } setTimeout(() => { scoreSpans[0].classList.remove('updated'); scoreSpans[1].classList.remove('updated'); }, 400); },
                drawWinningLine(winningItem) {
                    const boardRect = dom.gameBoard.getBoundingClientRect(); const cellSize = boardRect.width / 3; const halfCell = cellSize / 2;
                    const coords = {
                        h1:{x1:halfCell,y1:halfCell,x2:boardRect.width-halfCell,y2:halfCell},h2:{x1:halfCell,y1:cellSize+halfCell,x2:boardRect.width-halfCell,y2:cellSize+halfCell},h3:{x1:halfCell,y1:cellSize*2+halfCell,x2:boardRect.width-halfCell,y2:cellSize*2+halfCell},
                        v1:{x1:halfCell,y1:halfCell,x2:halfCell,y2:boardRect.height-halfCell},v2:{x1:cellSize+halfCell,y1:halfCell,x2:cellSize+halfCell,y2:boardRect.height-halfCell},v3:{x1:cellSize*2+halfCell,y1:halfCell,x2:cellSize*2+halfCell,y2:boardRect.height-halfCell},
                        d1:{x1:halfCell,y1:halfCell,x2:boardRect.width-halfCell,y2:boardRect.height-halfCell},d2:{x1:boardRect.width-halfCell,y1:halfCell,x2:halfCell,y2:boardRect.height-halfCell}
                    };
                    const pos = coords[winningItem.name]; const winnerColor = state.isOTurn ? 'var(--color-o)' : 'var(--color-x)';
                    const line = dom.winningLine.line; line.setAttribute('x1',pos.x1);line.setAttribute('y1',pos.y1);line.setAttribute('x2',pos.x2);line.setAttribute('y2',pos.y2);
                    line.style.stroke = winnerColor; dom.winningLine.svg.style.visibility = 'visible';
                    winningItem.combo.forEach(index => dom.cellElements[index].classList.add('winning-cell'));
                },
                showEndGameMessage(draw) {
                    let winnerMark = state.isOTurn ? O_CLASS : X_CLASS;
                    let message = draw ? 'Draw!' : (winnerMark === state.playerMark ? 'You Win!' : 'AI Wins!');
                    dom.winningMessageText.innerText = message; this.toggleOverlay(dom.overlays.winning, true);
                    this.announce(message + " Press Play Again to continue.");
                },
                announce: (message) => dom.ariaLiveRegion.textContent = message
            };
            const game = {
                start() {
                    state.isGameActive = true; state.isOTurn = false; state.board.fill(null);
                    ui.toggleOverlay(dom.overlays.winning, false); dom.winningLine.svg.style.visibility = 'hidden';
                    dom.gameBoard.style.pointerEvents = 'auto';
                    if (state.isPlayerTurnToStart) { state.playerMark = X_CLASS; state.aiMark = O_CLASS; }
                    else { state.playerMark = O_CLASS; state.aiMark = X_CLASS; }
                    ui.update(); ui.announce(`New game started. ${state.isPlayerTurnToStart ? 'Your' : `AI's`} turn as X.`);
                    if (!state.isPlayerTurnToStart) this.triggerAIMove();
                },
                handleCellClick(e) {
                    if (!e.target.matches('[data-cell-index]')) return;
                    const index = parseInt(e.target.dataset.cellIndex);
                    if (!state.isGameActive || state.board[index] !== null) return;
                    const currentClass = state.isOTurn ? O_CLASS : X_CLASS;
                    if (state.gameMode === 'pvc' && currentClass === state.aiMark) return;
                    this.placeMark(index, currentClass); ui.announce(`You placed ${currentClass.toUpperCase()} in cell ${index + 1}`);
                    if (this.processMove(currentClass)) return;
                    if (state.gameMode === 'pvc') this.triggerAIMove();
                },
                placeMark(index, currentClass) { state.board[index] = currentClass; ui.updateBoard(); },
                swapTurns() { state.isOTurn = !state.isOTurn; ui.updateTurnIndicator(); ui.announce(`${state.isOTurn ? 'O' : 'X'}'s turn.`); },
                processMove(currentClass) {
                    const winningCombination = this.checkWin(currentClass);
                    if (winningCombination) { this.end(false, winningCombination); return true; }
                    if (this.isDraw()) { this.end(true); return true; }
                    this.swapTurns(); return false;
                },
                triggerAIMove() {
                    ui.toggleOverlay(dom.overlays.aiThinking, true);
                    setTimeout(() => { ai.move(); ui.toggleOverlay(dom.overlays.aiThinking, false); }, Math.random() * 250 + 300);
                },
                end(draw, winningCombination = null) {
                    state.isGameActive = false; dom.gameBoard.style.pointerEvents = 'none';
                    if (!draw) {
                        const winnerMark = state.isOTurn ? O_CLASS : X_CLASS;
                        if(winnerMark === state.playerMark) { state.score.player++; audio.playWin(); }
                        else { state.score.ai++; }
                        ui.updateScoreDisplay(); ui.flashScore(winnerMark); ui.drawWinningLine(winningCombination);
                    }
                    state.isPlayerTurnToStart = !state.isPlayerTurnToStart;
                    setTimeout(() => ui.showEndGameMessage(draw), winningCombination ? 800 : 100);
                },
                checkWin: (player, board = state.board) => WINNING_COMBINATIONS.find(item => item.combo.every(index => board[index] === player)),
                isDraw: () => state.board.every(cell => cell !== null)
            };
            const ai = {
                move() {
                    if (!state.isGameActive) return;
                    const availableSpots = state.board.map((v, i) => v === null ? i : null).filter(v => v !== null);
                    if (state.difficulty === 'easy') {
                        const randomIndex = availableSpots[Math.floor(Math.random() * availableSpots.length)];
                        game.placeMark(randomIndex, state.aiMark); this.announceMove(randomIndex); game.processMove(state.aiMark); return;
                    }
                    if (availableSpots.length === 9) {
                        const openingMoves = [4, 0, 2, 6, 8];
                        const randomMove = openingMoves[Math.floor(Math.random() * openingMoves.length)];
                        game.placeMark(randomMove, state.aiMark); this.announceMove(randomMove); game.processMove(state.aiMark); return;
                    }
                    const aiWinMoves = this.findAllWinningMoves(state.aiMark);
                    if (aiWinMoves.length > 0) {
                        const randomWinMove = aiWinMoves[Math.floor(Math.random() * aiWinMoves.length)];
                        game.placeMark(randomWinMove, state.aiMark); this.announceMove(randomWinMove); game.processMove(state.aiMark); return;
                    }
                    const playerWinMoves = this.findAllWinningMoves(state.playerMark);
                    if (playerWinMoves.length > 0) {
                        const randomBlockMove = playerWinMoves[Math.floor(Math.random() * playerWinMoves.length)];
                        game.placeMark(randomBlockMove, state.aiMark); this.announceMove(randomBlockMove); game.processMove(state.aiMark); return;
                    }
                    const sortedMoves = this.minimax([...state.board], state.aiMark);
                    const personality = Math.random();
                    let chosenMove;
                    if (personality < 0.70 && sortedMoves.length > 0) { chosenMove = sortedMoves[0]; }
                    else if (personality < 0.95 && sortedMoves.length > 1) { chosenMove = sortedMoves[1]; }
                    else if (sortedMoves.length > 2) { chosenMove = sortedMoves[2]; }
                    else { chosenMove = sortedMoves[0]; }
                    game.placeMark(chosenMove.index, state.aiMark); this.announceMove(chosenMove.index);
                    game.processMove(state.aiMark);
                },
                announceMove: (index) => ui.announce(`AI placed ${state.aiMark.toUpperCase()} in cell ${index + 1}`),
                findAllWinningMoves(player) {
                    const moves = [];
                    for (let i = 0; i < 9; i++) { if (state.board[i] === null) { const tempBoard = [...state.board]; tempBoard[i] = player; if (game.checkWin(player, tempBoard)) moves.push(i); } }
                    return moves;
                },
                minimax(newBoard, player) {
                    const availableSpots = newBoard.map((v, i) => v === null ? i : null).filter(v => v !== null);
                    if (game.checkWin(state.playerMark, newBoard)) return [{ score: -10 }];
                    if (game.checkWin(state.aiMark, newBoard)) return [{ score: 10 }];
                    if (availableSpots.length === 0) return [{ score: 0 }];
                    const moves = [];
                    for (const spot of availableSpots) {
                        const move = { index: spot };
                        newBoard[spot] = player;
                        const result = this.minimax(newBoard, player === state.aiMark ? state.playerMark : state.aiMark);
                        move.score = result[0].score;
                        newBoard[spot] = null;
                        moves.push(move);
                    }
                    return moves.sort((a, b) => (player === state.aiMark) ? b.score - a.score : a.score - b.score);
                }
            };
            function setupEventListeners() {
                audio.fadeInMusic(); 
                dom.buttons.soundToggle.addEventListener('click', () => {
                    state.soundOn = !state.soundOn;
                    dom.buttons.soundToggle.textContent = state.soundOn ? "ðŸ”Š Sound On" : "ðŸ”‡ Sound Off";
                    audio.updateMusicState();
                    audio.playClick();
                });
                
                document.addEventListener('mousedown', (e) => {
                    if (e.target.matches('.btn, .cell')) {
                        audio.playClick();
                        if (e.target.matches('.btn')) {
                            const colorVar = e.target.classList.contains('btn-secondary') ? '--color-o' : '--color-x';
                            const shatterColor = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim();
                            effects.createShatter(e.clientX, e.clientY, shatterColor);
                        }
                    }
                });

                dom.buttons.pvp.addEventListener('click', () => { state.gameMode = 'pvp'; ui.showView('gameScreen'); });
                dom.buttons.pvc.addEventListener('click', () => { state.gameMode = 'pvc'; ui.showView('difficultySelection'); });
                [dom.buttons.easy, dom.buttons.hard].forEach(btn => btn.addEventListener('click', (e) => {
                    state.difficulty = e.target.dataset.difficulty;
                    ui.showView('gameScreen');
                }));
                dom.buttons.universalBack.addEventListener('click', () => { ui.toggleOverlay(dom.overlays.exitConfirmation, true); });
                dom.buttons.cancelExit.addEventListener('click', () => { ui.toggleOverlay(dom.overlays.exitConfirmation, false); });
                dom.buttons.confirmExit.addEventListener('click', () => {
                    state.isGameActive = false;
                    ui.toggleOverlay(dom.overlays.exitConfirmation, false);
                    ui.showView(dom.buttons.universalBack.dataset.target);
                });
                dom.buttons.restart.addEventListener('click', () => game.start());
                dom.gameBoard.addEventListener('click', game.handleCellClick.bind(game));
            }
            setupEventListeners();
            ui.showView('mainMenu');
        });
    </script>
</body>
</html>
